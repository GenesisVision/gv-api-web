/**
 * Core API v1.0
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import ApiClient from "../ApiClient";
import CancelablePromise from "../cancelable-promise/CancelablePromise.js";
import { ErrorViewModel } from "../model/errorViewModel";
import { ProgramBalanceChartOld } from "../model/programBalanceChartOld";
import { ProgramDetailsFullOld } from "../model/programDetailsFullOld";
import { ProgramPeriodsViewModel } from "../model/programPeriodsViewModel";
import { ProgramProfitChartOld } from "../model/programProfitChartOld";
import { ProgramSets } from "../model/programSets";
import { ProgramsListOld } from "../model/programsListOld";
import { SignalProviderSubscribers } from "../model/signalProviderSubscribers";
import { TradesViewModel } from "../model/tradesViewModel";

export class ProgramsService {
  apiClient: ApiClient;

  constructor(apiClient?: ApiClient) {
    this.apiClient = apiClient || ApiClient.instance;
  }

  public addToFavorites(id: string, authorization: string): CancelablePromise<null>{
    return this.addToFavoritesWithHttpInfo(id, authorization)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private addToFavoritesWithHttpInfo(id: string, authorization: string){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling addToFavorites");
    }
    // verify the required parameter "authorization" is set
    if (authorization === undefined || authorization === null) {
      throw new Error("Missing the required parameter \"authorization\" when calling addToFavorites");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
    };
    let headerParams = { 
      "Authorization": authorization
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = null;

    return this.apiClient.callApi<null>(
      '/v1.0/programs/{id}/favorite/add', 'POST',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public exportProgramPeriods(id: string, opts?: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    numberMin?: number, 
    numberMax?: number, 
    status?: 'Planned' | 'InProccess' | 'Closed', 
    skip?: number, 
    take?: number
  }): CancelablePromise<Blob>{
    return this.exportProgramPeriodsWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private exportProgramPeriodsWithHttpInfo(id: string, opts: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    numberMin?: number, 
    numberMax?: number, 
    status?: 'Planned' | 'InProccess' | 'Closed', 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling exportProgramPeriods");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "DateFrom": opts["dateFrom"],
      "DateTo": opts["dateTo"],
      "NumberMin": opts["numberMin"],
      "NumberMax": opts["numberMax"],
      "Status": opts["status"],
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = 'Blob';

    return this.apiClient.callApi<Blob>(
      '/v1.0/programs/{id}/periods/export', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public exportProgramPeriodsFinStatistic(id: string, authorization: string, opts?: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    numberMin?: number, 
    numberMax?: number, 
    status?: 'Planned' | 'InProccess' | 'Closed', 
    skip?: number, 
    take?: number
  }): CancelablePromise<Blob>{
    return this.exportProgramPeriodsFinStatisticWithHttpInfo(id, authorization, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private exportProgramPeriodsFinStatisticWithHttpInfo(id: string, authorization: string, opts: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    numberMin?: number, 
    numberMax?: number, 
    status?: 'Planned' | 'InProccess' | 'Closed', 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling exportProgramPeriodsFinStatistic");
    }
    // verify the required parameter "authorization" is set
    if (authorization === undefined || authorization === null) {
      throw new Error("Missing the required parameter \"authorization\" when calling exportProgramPeriodsFinStatistic");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "DateFrom": opts["dateFrom"],
      "DateTo": opts["dateTo"],
      "NumberMin": opts["numberMin"],
      "NumberMax": opts["numberMax"],
      "Status": opts["status"],
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
      "Authorization": authorization
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = 'Blob';

    return this.apiClient.callApi<Blob>(
      '/v1.0/programs/{id}/periods/export/statistic', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public exportTrades(id: string, opts?: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    symbol?: string, 
    sorting?: 'ByDateAsc' | 'ByDateDesc' | 'ByTicketAsc' | 'ByTicketDesc' | 'BySymbolAsc' | 'BySymbolDesc' | 'ByDirectionAsc' | 'ByDirectionDesc' | 'ByVolumeAsc' | 'ByVolumeDesc' | 'ByPriceAsc' | 'ByPriceDesc' | 'ByPriceCurrentAsc' | 'ByPriceCurrentDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByCommissionAsc' | 'ByCommissionDesc' | 'BySwapAsc' | 'BySwapDesc', 
    accountId?: string, 
    accountCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    skip?: number, 
    take?: number
  }): CancelablePromise<Blob>{
    return this.exportTradesWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private exportTradesWithHttpInfo(id: string, opts: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    symbol?: string, 
    sorting?: 'ByDateAsc' | 'ByDateDesc' | 'ByTicketAsc' | 'ByTicketDesc' | 'BySymbolAsc' | 'BySymbolDesc' | 'ByDirectionAsc' | 'ByDirectionDesc' | 'ByVolumeAsc' | 'ByVolumeDesc' | 'ByPriceAsc' | 'ByPriceDesc' | 'ByPriceCurrentAsc' | 'ByPriceCurrentDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByCommissionAsc' | 'ByCommissionDesc' | 'BySwapAsc' | 'BySwapDesc', 
    accountId?: string, 
    accountCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling exportTrades");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "DateFrom": opts["dateFrom"],
      "DateTo": opts["dateTo"],
      "Symbol": opts["symbol"],
      "Sorting": opts["sorting"],
      "AccountId": opts["accountId"],
      "AccountCurrency": opts["accountCurrency"],
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = 'Blob';

    return this.apiClient.callApi<Blob>(
      '/v1.0/programs/{id}/trades/export', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramBalanceChart(id: string, opts?: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    maxPointCount?: number, 
    currency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR'
  }): CancelablePromise<ProgramBalanceChartOld>{
    return this.getProgramBalanceChartWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramBalanceChartWithHttpInfo(id: string, opts: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    maxPointCount?: number, 
    currency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR'
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling getProgramBalanceChart");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "DateFrom": opts["dateFrom"],
      "DateTo": opts["dateTo"],
      "MaxPointCount": opts["maxPointCount"],
      "Currency": opts["currency"]
    };
    let headerParams = { 
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = ProgramBalanceChartOld;

    return this.apiClient.callApi<ProgramBalanceChartOld>(
      '/v1.0/programs/{id}/charts/balance', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramDetails(id: string, opts?: { 
    authorization?: string, 
    currencySecondary?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR'
  }): CancelablePromise<ProgramDetailsFullOld>{
    return this.getProgramDetailsWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramDetailsWithHttpInfo(id: string, opts: { 
    authorization?: string, 
    currencySecondary?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR'
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling getProgramDetails");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "currencySecondary": opts["currencySecondary"]
    };
    let headerParams = { 
      "Authorization": opts["authorization"]
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = ProgramDetailsFullOld;

    return this.apiClient.callApi<ProgramDetailsFullOld>(
      '/v1.0/programs/{id}', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramOpenTrades(id: string, opts?: { 
    sorting?: 'ByDateAsc' | 'ByDateDesc' | 'ByTicketAsc' | 'ByTicketDesc' | 'BySymbolAsc' | 'BySymbolDesc' | 'ByDirectionAsc' | 'ByDirectionDesc' | 'ByVolumeAsc' | 'ByVolumeDesc' | 'ByPriceAsc' | 'ByPriceDesc' | 'ByPriceCurrentAsc' | 'ByPriceCurrentDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByCommissionAsc' | 'ByCommissionDesc' | 'BySwapAsc' | 'BySwapDesc', 
    symbol?: string, 
    accountId?: string, 
    accountCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    skip?: number, 
    take?: number
  }): CancelablePromise<TradesViewModel>{
    return this.getProgramOpenTradesWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramOpenTradesWithHttpInfo(id: string, opts: { 
    sorting?: 'ByDateAsc' | 'ByDateDesc' | 'ByTicketAsc' | 'ByTicketDesc' | 'BySymbolAsc' | 'BySymbolDesc' | 'ByDirectionAsc' | 'ByDirectionDesc' | 'ByVolumeAsc' | 'ByVolumeDesc' | 'ByPriceAsc' | 'ByPriceDesc' | 'ByPriceCurrentAsc' | 'ByPriceCurrentDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByCommissionAsc' | 'ByCommissionDesc' | 'BySwapAsc' | 'BySwapDesc', 
    symbol?: string, 
    accountId?: string, 
    accountCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling getProgramOpenTrades");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "Sorting": opts["sorting"],
      "Symbol": opts["symbol"],
      "AccountId": opts["accountId"],
      "AccountCurrency": opts["accountCurrency"],
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = TradesViewModel;

    return this.apiClient.callApi<TradesViewModel>(
      '/v1.0/programs/{id}/trades/open', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramPeriods(id: string, opts?: { 
    authorization?: string, 
    dateFrom?: Date, 
    dateTo?: Date, 
    numberMin?: number, 
    numberMax?: number, 
    status?: 'Planned' | 'InProccess' | 'Closed', 
    skip?: number, 
    take?: number
  }): CancelablePromise<ProgramPeriodsViewModel>{
    return this.getProgramPeriodsWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramPeriodsWithHttpInfo(id: string, opts: { 
    authorization?: string, 
    dateFrom?: Date, 
    dateTo?: Date, 
    numberMin?: number, 
    numberMax?: number, 
    status?: 'Planned' | 'InProccess' | 'Closed', 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling getProgramPeriods");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "DateFrom": opts["dateFrom"],
      "DateTo": opts["dateTo"],
      "NumberMin": opts["numberMin"],
      "NumberMax": opts["numberMax"],
      "Status": opts["status"],
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
      "Authorization": opts["authorization"]
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = ProgramPeriodsViewModel;

    return this.apiClient.callApi<ProgramPeriodsViewModel>(
      '/v1.0/programs/{id}/periods', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramProfitChart(id: string, opts?: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    maxPointCount?: number, 
    currency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR'
  }): CancelablePromise<ProgramProfitChartOld>{
    return this.getProgramProfitChartWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramProfitChartWithHttpInfo(id: string, opts: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    maxPointCount?: number, 
    currency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR'
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling getProgramProfitChart");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "DateFrom": opts["dateFrom"],
      "DateTo": opts["dateTo"],
      "MaxPointCount": opts["maxPointCount"],
      "Currency": opts["currency"]
    };
    let headerParams = { 
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = ProgramProfitChartOld;

    return this.apiClient.callApi<ProgramProfitChartOld>(
      '/v1.0/programs/{id}/charts/profit', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramSets(authorization: string): CancelablePromise<ProgramSets>{
    return this.getProgramSetsWithHttpInfo(authorization)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramSetsWithHttpInfo(authorization: string){
    let postBody = null;
    
    // verify the required parameter "authorization" is set
    if (authorization === undefined || authorization === null) {
      throw new Error("Missing the required parameter \"authorization\" when calling getProgramSets");
    }

    let pathParams = { 
    };
    let queryParams = { 
    };
    let headerParams = { 
      "Authorization": authorization
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = ProgramSets;

    return this.apiClient.callApi<ProgramSets>(
      '/v1.0/programs/sets', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramSubscribers(id: string, authorization: string, opts?: { 
    status?: 'All' | 'Active', 
    skip?: number, 
    take?: number
  }): CancelablePromise<SignalProviderSubscribers>{
    return this.getProgramSubscribersWithHttpInfo(id, authorization, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramSubscribersWithHttpInfo(id: string, authorization: string, opts: { 
    status?: 'All' | 'Active', 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling getProgramSubscribers");
    }
    // verify the required parameter "authorization" is set
    if (authorization === undefined || authorization === null) {
      throw new Error("Missing the required parameter \"authorization\" when calling getProgramSubscribers");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "Status": opts["status"],
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
      "Authorization": authorization
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = SignalProviderSubscribers;

    return this.apiClient.callApi<SignalProviderSubscribers>(
      '/v1.0/programs/{id}/subscribers', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getProgramTrades(id: string, opts?: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    symbol?: string, 
    sorting?: 'ByDateAsc' | 'ByDateDesc' | 'ByTicketAsc' | 'ByTicketDesc' | 'BySymbolAsc' | 'BySymbolDesc' | 'ByDirectionAsc' | 'ByDirectionDesc' | 'ByVolumeAsc' | 'ByVolumeDesc' | 'ByPriceAsc' | 'ByPriceDesc' | 'ByPriceCurrentAsc' | 'ByPriceCurrentDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByCommissionAsc' | 'ByCommissionDesc' | 'BySwapAsc' | 'BySwapDesc', 
    accountId?: string, 
    accountCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    skip?: number, 
    take?: number
  }): CancelablePromise<TradesViewModel>{
    return this.getProgramTradesWithHttpInfo(id, opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramTradesWithHttpInfo(id: string, opts: { 
    dateFrom?: Date, 
    dateTo?: Date, 
    symbol?: string, 
    sorting?: 'ByDateAsc' | 'ByDateDesc' | 'ByTicketAsc' | 'ByTicketDesc' | 'BySymbolAsc' | 'BySymbolDesc' | 'ByDirectionAsc' | 'ByDirectionDesc' | 'ByVolumeAsc' | 'ByVolumeDesc' | 'ByPriceAsc' | 'ByPriceDesc' | 'ByPriceCurrentAsc' | 'ByPriceCurrentDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByCommissionAsc' | 'ByCommissionDesc' | 'BySwapAsc' | 'BySwapDesc', 
    accountId?: string, 
    accountCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling getProgramTrades");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
      "DateFrom": opts["dateFrom"],
      "DateTo": opts["dateTo"],
      "Symbol": opts["symbol"],
      "Sorting": opts["sorting"],
      "AccountId": opts["accountId"],
      "AccountCurrency": opts["accountCurrency"],
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = TradesViewModel;

    return this.apiClient.callApi<TradesViewModel>(
      '/v1.0/programs/{id}/trades', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public getPrograms(opts?: { 
    authorization?: string, 
    levelMin?: number, 
    levelMax?: number, 
    levelsSet?: Array<number>, 
    profitAvgMin?: number, 
    profitAvgMax?: number, 
    sorting?: 'ByLevelAsc' | 'ByLevelDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByDrawdownAsc' | 'ByDrawdownDesc' | 'ByTradesAsc' | 'ByTradesDesc' | 'ByInvestorsAsc' | 'ByInvestorsDesc' | 'ByNewDesc' | 'ByNewAsc' | 'ByEndOfPeriodAsc' | 'ByEndOfPeriodDesc' | 'ByTitleAsc' | 'ByTitleDesc' | 'ByBalanceAsc' | 'ByBalanceDesc' | 'ByCurrDesc' | 'ByCurrAsc' | 'ByLevelProgressDesc' | 'ByLevelProgressAsc', 
    programCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    currencySecondary?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    currency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    levelUpFrom?: number, 
    tags?: Array<string>, 
    isSignal?: boolean, 
    statisticDateFrom?: Date, 
    statisticDateTo?: Date, 
    chartPointsCount?: number, 
    mask?: string, 
    facetId?: string, 
    isFavorite?: boolean, 
    isEnabled?: boolean, 
    hasInvestorsForAll?: boolean, 
    hasInvestorsForClosed?: boolean, 
    ids?: Array<string>, 
    forceUseIdsList?: boolean, 
    managerId?: string, 
    programManagerId?: string, 
    status?: Array<Object>, 
    skip?: number, 
    take?: number
  }): CancelablePromise<ProgramsListOld>{
    return this.getProgramsWithHttpInfo(opts)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private getProgramsWithHttpInfo(opts: { 
    authorization?: string, 
    levelMin?: number, 
    levelMax?: number, 
    levelsSet?: Array<number>, 
    profitAvgMin?: number, 
    profitAvgMax?: number, 
    sorting?: 'ByLevelAsc' | 'ByLevelDesc' | 'ByProfitAsc' | 'ByProfitDesc' | 'ByDrawdownAsc' | 'ByDrawdownDesc' | 'ByTradesAsc' | 'ByTradesDesc' | 'ByInvestorsAsc' | 'ByInvestorsDesc' | 'ByNewDesc' | 'ByNewAsc' | 'ByEndOfPeriodAsc' | 'ByEndOfPeriodDesc' | 'ByTitleAsc' | 'ByTitleDesc' | 'ByBalanceAsc' | 'ByBalanceDesc' | 'ByCurrDesc' | 'ByCurrAsc' | 'ByLevelProgressDesc' | 'ByLevelProgressAsc', 
    programCurrency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    currencySecondary?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    currency?: 'Undefined' | 'GVT' | 'ETH' | 'BTC' | 'ADA' | 'USDT' | 'XRP' | 'BCH' | 'LTC' | 'DOGE' | 'BNB' | 'USD' | 'EUR', 
    levelUpFrom?: number, 
    tags?: Array<string>, 
    isSignal?: boolean, 
    statisticDateFrom?: Date, 
    statisticDateTo?: Date, 
    chartPointsCount?: number, 
    mask?: string, 
    facetId?: string, 
    isFavorite?: boolean, 
    isEnabled?: boolean, 
    hasInvestorsForAll?: boolean, 
    hasInvestorsForClosed?: boolean, 
    ids?: Array<string>, 
    forceUseIdsList?: boolean, 
    managerId?: string, 
    programManagerId?: string, 
    status?: Array<Object>, 
    skip?: number, 
    take?: number
  } = {}){
    let postBody = null;
    

    let pathParams = { 
    };
    let queryParams = { 
      "LevelMin": opts["levelMin"],
      "LevelMax": opts["levelMax"],
      "LevelsSet": this.apiClient.buildCollectionParam(opts["levelsSet"], "multi"),
      "ProfitAvgMin": opts["profitAvgMin"],
      "ProfitAvgMax": opts["profitAvgMax"],
      "Sorting": opts["sorting"],
      "ProgramCurrency": opts["programCurrency"],
      "CurrencySecondary": opts["currencySecondary"],
      "Currency": opts["currency"],
      "LevelUpFrom": opts["levelUpFrom"],
      "Tags": this.apiClient.buildCollectionParam(opts["tags"], "multi"),
      "IsSignal": opts["isSignal"],
      "StatisticDateFrom": opts["statisticDateFrom"],
      "StatisticDateTo": opts["statisticDateTo"],
      "ChartPointsCount": opts["chartPointsCount"],
      "Mask": opts["mask"],
      "FacetId": opts["facetId"],
      "IsFavorite": opts["isFavorite"],
      "IsEnabled": opts["isEnabled"],
      "HasInvestorsForAll": opts["hasInvestorsForAll"],
      "HasInvestorsForClosed": opts["hasInvestorsForClosed"],
      "Ids": this.apiClient.buildCollectionParam(opts["ids"], "multi"),
      "ForceUseIdsList": opts["forceUseIdsList"],
      "ManagerId": opts["managerId"],
      "ProgramManagerId": opts["programManagerId"],
      "Status": this.apiClient.buildCollectionParam(opts["status"], "multi"),
      "Skip": opts["skip"],
      "Take": opts["take"]
    };
    let headerParams = { 
      "Authorization": opts["authorization"]
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = ProgramsListOld;

    return this.apiClient.callApi<ProgramsListOld>(
      '/v1.0/programs', 'GET',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }

  public removeFromFavorites(id: string, authorization: string): CancelablePromise<null>{
    return this.removeFromFavoritesWithHttpInfo(id, authorization)
      .then(function(response_and_data) {
        return response_and_data.data;
      });
  }

  private removeFromFavoritesWithHttpInfo(id: string, authorization: string){
    let postBody = null;
    
    // verify the required parameter "id" is set
    if (id === undefined || id === null) {
      throw new Error("Missing the required parameter \"id\" when calling removeFromFavorites");
    }
    // verify the required parameter "authorization" is set
    if (authorization === undefined || authorization === null) {
      throw new Error("Missing the required parameter \"authorization\" when calling removeFromFavorites");
    }

    let pathParams = { 
      "id": id
    };
    let queryParams = { 
    };
    let headerParams = { 
      "Authorization": authorization
    };
    let formParams = { 
    };

    let authNames: string[] = [];
    let contentTypes: string[] = [];
    let accepts: string[] = ["text/plain", "application/json", "text/json"];
    let returnType = null;

    return this.apiClient.callApi<null>(
      '/v1.0/programs/{id}/favorite/remove', 'POST',
      pathParams, queryParams, headerParams, formParams, postBody,
      authNames, contentTypes, accepts, returnType
    );

  }
}
