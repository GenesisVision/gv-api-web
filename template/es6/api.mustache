{{>licenseInfo}}

{{=< >=}}
import ApiClient from "../ApiClient";
<#imports>import <import> from '../<#modelPackage><&modelPackage>/</modelPackage><import>';
</imports>

<#emitJSDoc>/**
* <baseName> service.
* @class <classname>
* @version <projectVersion>
*/</emitJSDoc>
export default class <classname> {

    <#emitJSDoc>/**
    * Constructs a new <&classname>. <#description>
    * <description></description>
    * @function <classname>#constructor
    * @param {ApiClient} apiClient Optional API client implementation to use,
    * @return {<classname>}
    */</emitJSDoc>
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }

<#operations><#operation>
      <operationId><#usePromises>WithHttpInfo</usePromises>(<vendorExtensions.x-codegen-argList>) {<#hasOptionalParams>
      opts = opts || {};</hasOptionalParams>
      let postBody = <#bodyParam><#required><paramName></required><^required>opts['<paramName>']</required></bodyParam><^bodyParam>null</bodyParam>;
<#allParams><#required>
      // verify the required parameter '<paramName>' is set
      if (<paramName> === undefined || <paramName> === null) {
        throw new Error("Missing the required parameter '<paramName>' when calling <operationId>");
      }
</required></allParams>

      let pathParams = {<#pathParams>
        '<baseName>': <#required><paramName></required><^required>opts['<paramName>']</required><#hasMore>,</hasMore></pathParams>
      };
      let queryParams = {<#queryParams>
        '<baseName>': <#collectionFormat>this.apiClient.buildCollectionParam(<#required><paramName></required><^required>opts['<paramName>']</required>, '<collectionFormat>')</collectionFormat><^collectionFormat><#required><paramName></required><^required>opts['<paramName>']</required></collectionFormat><#hasMore>,</hasMore></queryParams>
      };
      let headerParams = {<#headerParams>
        '<baseName>': <#required><paramName></required><^required>opts['<paramName>']</required><#hasMore>,</hasMore></headerParams>
      };
      let formParams = {<#formParams>
        '<baseName>': <#collectionFormat>this.apiClient.buildCollectionParam(<#required><paramName></required><^required>opts['<paramName>']</required>, '<collectionFormat>')</collectionFormat><^collectionFormat><#required><paramName></required><^required>opts['<paramName>']</required></collectionFormat><#hasMore>,</hasMore></formParams>
      };

      let authNames = [<#authMethods>'<name>'<#hasMore>, </hasMore></authMethods>];
      let contentTypes = [<#consumes>'<& mediaType>'<#hasMore>, </hasMore></consumes>];
      let accepts = [<#produces>'<& mediaType>'<#hasMore>, </hasMore></produces>];
      let returnType = <#returnType><&returnType></returnType><^returnType>null</returnType>;

      return this.apiClient.callApi<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}null{{/returnType}}>(
        '{{{path}}}', '{{{httpMethod}}}',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }
<#usePromises>
    <#emitJSDoc>

    /**<#summary>
     * <summary></summary><#notes>
     * <notes></notes>
     * @function <classname>#<operationId><#allParams><#required>
     * @param {<dataType>} <paramName> <description></required></allParams><#hasOptionalParams>
     * @param {Object} [opts] Optional parameters<#allParams><^required>
     * @param {<dataType>} [opts.<paramName>] <description><#defaultValue> (default to <.>)</defaultValue></required></allParams></hasOptionalParams><^usePromises>
     * @param {<#apiPackage><&apiPackage>/</apiPackage><&classname>~<operationId>Callback} callback The callback function, accepting three arguments: error, data, response<#returnType>
     * data is of type: {@link <&vendorExtensions.x-jsdoc-type>}</returnType></usePromises><#usePromises>
     * @return {CancelablePromise<#returnType><={{ }}=><{{&returnType}}>{{=< >=}}</returnType><^returnType><={{ }}=><any>{{=< >=}}</returnType>} a Promise<#returnType>, with an object containing data of type <&returnType> and HTTP response</returnType><^returnType>, with an object containing HTTP response</returnType></usePromises>
     */
</emitJSDoc>
      <operationId>(<vendorExtensions.x-codegen-argList>) {
      return this.<operationId>WithHttpInfo(<vendorExtensions.x-codegen-argList>)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }
</usePromises>
</operation></operations>

}
<={{ }}=>
